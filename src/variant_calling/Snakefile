configfile: "../config.yaml"

species_paths = [folder for folder in os.scandir(config["samples_dir"]) if folder.is_dir()]
samples_by_specie = {
    specie.name: [os.path.splitext(sample.name)[0] for sample in os.scandir(specie) if sample.name.endswith(".fna")] 
    for specie in species_paths
}

rule all:
    input:
        "results/snps_table.csv"

rule download_reference_genomes:
    output:
        fasta="reference_genomes/{specie_id}/{specie_id}.fna",
        gff="reference_genomes/{specie_id}/{specie_id}.gff"
    conda:
        "envs/ncbi.yaml"
    shell:
        """
        bash scripts/download_reference_genome.sh {wildcards.specie_id} {output.fasta} {output.gff}
        """

rule index_reference_genome:
    input:
        "reference_genomes/{specie_id}/{specie_id}.fna"
    output:
        "reference_genomes/{specie_id}/{specie_id}"+".fna.pac"
    conda:
        "envs/mapping.yaml"
    shell:
        "bwa index {input}"

rule map_reads:
    input:
        ref="reference_genomes/{specie_id}/{specie_id}"+".fna.pac",
        fasta=config["samples_dir"]+"/{specie_id}/{sample}.fna"
    output:
        temp("results/mapped/{specie_id}/{sample}.bam")
    conda:
        "envs/mapping.yaml"
    shell:
        "bwa mem -t {threads} reference_genomes/{wildcards.specie_id}/{wildcards.specie_id}.fna {input.fasta} | samtools view -Sb - > {output}"

rule sort_alignments:
    input:
        "results/mapped/{specie_id}/{sample}.bam"
    output:
        temp("results/mapped/{specie_id}/{sample}.sorted.bam")
    conda:
        "envs/mapping.yaml"
    shell:
        "samtools sort -o {output} {input}"

rule call_variants:
    input:
        ref="reference_genomes/{specie_id}/{specie_id}.fna",
        bam="results/mapped/{specie_id}/{sample}.sorted.bam"
    output:
        temp("results/calls/{specie_id}/{sample}.vcf.gz")
    conda:
        "envs/calling.yaml"
    shell:
        "bcftools mpileup -f {input.ref} {input.bam} | bcftools call -mv -Oz > {output}"

rule filter_variants:
    input:
        "results/calls/{specie_id}/{sample}.vcf.gz"
    output:
        temp("results/filters/{specie_id}/{sample}.filtered.vcf")
    conda:
        "envs/calling.yaml"
    shell:
        "bcftools filter -i 'DP>=4 && QUAL>=30 && F_MISSING<0.2' {input} -o {output}"

rule keep_only_snps:
    input:
        "results/filters/{specie_id}/{sample}.filtered.vcf"
    output:
        temp("results/filters/{specie_id}/{sample}.filtered.snps.vcf")
    conda:
        "envs/filtering.yaml"
    shell:
        "vcftools --vcf {input} --remove-indels --recode --recode-INFO-all --stdout > {output}"

rule gff2bed:
    input:
        gff="reference_genomes/{specie_id}/{specie_id}.gff"
    output:
        "reference_genomes/{specie_id}/{specie_id}.bed"
    shell:
        """
        bash scripts/gff2bed.sh {input.gff} {output}
        """

rule annotate_snps:
    input:
        reference_bed="reference_genomes/{specie_id}/{specie_id}.bed",
        vcf="results/filters/{specie_id}/{sample}.filtered.snps.vcf"
    output:
        temp("results/annotations/{specie_id}/{sample}.annotated.snps.vcf")
    conda:
        "envs/calling.yaml"
    shell:
        """
        bcftools annotate -a {input.reference_bed} -c CHROM,FROM,TO,GENE \
        -h <(echo '##INFO=<ID=GENE,Number=1,Type=String,Description="Gene name">') \
        {input.vcf} > {output}
        """

rule select_columns:
    input:
        "results/annotations/{specie_id}/{sample}.annotated.snps.vcf"
    output:
        temp("results/{specie_id}/{sample}.filtered.snps.extract.tsv")
    conda:
        "envs/calling.yaml"
    shell:
        "bcftools query -f '%CHROM\t%POS\t%REF\t%FIRST_ALT\t[%TGT]\t%INFO/GENE\n' {input} -o {output}"

rule derive_snp_position:
    input:
        ref="reference_genomes/{specie_id}/{specie_id}.bed",
        snps="results/{specie_id}/{sample}.filtered.snps.extract.tsv"
    output:
        temp("results/{specie_id}/{sample}.filtered.snps.extract.hydrated.tsv")
    conda:
        "envs/merging.yaml"
    shell:
        "python scripts/derive_snp_position.py --ref {input.ref} --snps {input.snps} --output {output}"

rule merge_samples:
    input:
        ["results/{specie_id}/{sample}.filtered.snps.extract.hydrated.tsv".format(specie_id=specie_id, sample=sample)  
        for specie_id in samples_by_specie for sample in samples_by_specie[specie_id]]
    output:
        "results/snps_table.csv"
    conda:
        "envs/merging.yaml"
    shell:
        "python scripts/merge_samples.py {input} --output {output}"

#TODO: checkout why there are no snps for the salmonella samples