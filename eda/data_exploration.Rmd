---
title: "Data exploration"
author: "Geovanny Risco"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  github_document:
    keep_html: no
    number_sections: yes
    toc: yes
    toc_depth: 3
    df_print: tibble
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, rows.print = 25)

is_render_mode <- !is.null(knitr::current_input())
view_method <- if (is_render_mode) "render" else "viewer"
```

# Import libraries

```{r}
library(tidyverse)
```

# Read raw data

```{r}
# ARGs (Antibiotic Resistance Genes)
args_data <- read_csv("data/results/args_calling/args_table.csv", col_types = cols("sample_name" = col_character()))
## Fix/extract name of samples
args_data <- args_data %>%
  mutate(sample_name = str_extract(sample_name, "^\\w+.\\d+"))
args_data
```

```{r}
# SNPs (Single Nucleotide Polymorphisms)
snps_data <- read_tsv("data/results/variant_calling/snps_data.tsv", col_names = c("chrom", "pos", "ref", "alt", "tgt", "gene_name", "gene_pos", "tax_id", "sample_name"), na = c("."))
# Fix/extract name of samples
snps_data <- snps_data %>%
  mutate(sample_name = str_extract(sample_name, "^\\w+.\\d+"))
snps_data
```

```{r}
# Reference genomes (in BED format)

## Loop through reference genomes folder and read BED files
refs_genomes_dir <- "data/reference_genomes"
refs_genomes_files <- list.files(refs_genomes_dir, pattern = ".bed", full.names = TRUE, recursive = TRUE)
## Read each of the BED files and store them ina dictionary which key is the name of the file and the values a list of genes
refs_genomes <- list()
for (file in refs_genomes_files) {
  tax_id <- str_remove(basename(file), ".bed")
  refs_genomes[tax_id] <- read_tsv(file, col_select = 4)
}
```

```{r}
# AMR (Antimicrobial Resistance) labels
amr_labels <- read_csv("data/results/data_collection_ncbi/amr_labels.csv", col_types = cols("SampleID" = col_character()))
amr_labels
```

```{r}
# Load NCBI samples metadata
samples_metadata <- read_tsv("data/results/data_collection_ncbi/assembly_accession_ids+tax_ids.txt", col_names = c("biosample_accession", "assembly_accession", "tax_id"))
samples_metadata
```

For now and until BV-BRC is active again, we will filter out 1351 samples (which are not in NCBI).
In order to add BV-BRC samples, we need to parse AMR labels information in a different way:

```{r}
amr_labels <- amr_labels %>%
  filter(`SampleID` %in% samples_metadata$biosample_accession)
snps_data <- snps_data %>%
  filter(sample_name %in% samples_metadata$assembly_accession)
args_data <- args_data %>%
  filter(sample_name %in% samples_metadata$assembly_accession)
```


# Clean and prepare data

## ARGs

This table has the following structure:

sample_name | GeneA | GeneB | GeneC | ...
GCA_012637185.1 | 0 | 1 | 0 | ...
... | ... | ... | ... | ...

For each gene, a boolean value is given dependending on whether the gene is resistance or not.

* 1: resistance gene
* 0: non-resistance gene

### Null values detection

```{r}
# Count number of nulls per sample
args_data %>%
  mutate(nulls = rowSums(is.na(select(., -sample_name)))) %>%
  select(sample_name, nulls) %>%
  arrange(desc(nulls))
```

We have no nulls values for ARGs.

### Outliers detection

```{r}
# For each sample, how many resistance genes are present?
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  select(sample_name, count) %>%
  arrange(desc(count))
# Mean number of resistance genes per sample
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  summarise(mean(count))
# Boxplot summarizing above information
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  ggplot(aes(x = "", y = count)) +
  geom_boxplot() +
  labs(x = "", y = "Number of resistance genes", title = "Distribution of resistance genes per sample") +
  theme_bw()
```

\#TODO: add analysis when final data is ready

## SNPs

In this case, we will need to perform preparation steps for each sample, since the table has a different structure.

chrom | pos | ref | alt | tgt | gene_name | gene_pos | tax_id | sample_name
NC_002695.2	| 1250767 |	T |	C |	T/C |	ECs_1169 |	511.0 |	562 |	GCA_012688215.1
NC_002695.2 |	1250712 |	C |	A |	C/A |	ECs_1169 |	456.0 |	562	| GCA_012688215.1
NZ_CP046317.1	| 218754 | T	| G |	T/G |	FOC43_RS01045	| 603 |	195 |	GCA_005283725.1
... | ... | ... | ... | ... | ... | ... | ... | ...

Here is a brief description of each column:

* chrom: chromosome in which the SNP is located
* pos: position of the SNP in the chromosome
* ref: reference nucleotide (the one that is expected to be found in the sample)
* alt: alternative nucleotide (the one that is actually found in the sample, that is, the mutation/SNP)
* tgt: translated genotype, or in other words, the ref and alt nucleotides in a single string (ref/alt). #TODO: double check this
* gene_name: name of the gene in which the SNP is located
* gene_pos: position of the SNP in the gene
* tax_id: taxonomic id of the sample
* sample_name: name of the sample

Most of this information has been extracted from the VCF file generated by the variant calling pipeline. 
More information about the VCF format can be found [here](https://samtools.github.io/hts-specs/VCFv4.2.pdf).

In order to use this data for ML purposes, we need to transform it into a table with the following structure:

sample_name | gene_name1/gene1_pos1 | gene_name1/gene1_pos2 | gene_name2/gene2_pos1 | ...

For the previous example, the table would look like this:

sample_name | ECs_1169/456 | ECs_1169/1250712 | FOC43_RS01045/603 | ...
GCA_012688215.1 | C | NO-SNP | NULL | ...
GCA_012637185.1 | NO-SNP | A | NULL | ...
GCA_005283725.1 | NULL | NULL | G | ...

As we can see, each SNP is represented as a column, and each row represents a sample. For each SNP, we can have the following values:

* NO-SNP: no SNP found in this position of the gene, but the gene does belong to the sample
* NULL: the gene does not belong to the sample
* A, C, G, T: the SNP found in this position of the gene

In addition, we will encode these values into numerical values so that we do limit the number of ML algorithms we can use.
But before that, let's do some sanity checks.

```{r}
# Filter out SNPs with no gene name (which are the same as sample with non gene_pos)
snps_data <- snps_data %>%
  filter(!is.na(gene_name))
# Filter out SNPS which count for >5 in the same gene (this is considered an anomaly, due to reference genome, etc.) #TODO: double check this
MAX_NUMBER_OF_SNPS <- 5
snps_data <- snps_data %>%
  group_by(sample_name, gene_name) %>%
  mutate(count = n()) %>%
  filter(count <= MAX_NUMBER_OF_SNPS) %>%
  select(-count)
```

Pivot table with above specifications:

```{r}
snps_data_wide <- snps_data %>%
  select(sample_name, gene_name, gene_pos, alt) %>%
  pivot_wider(names_from = c("gene_pos"), values_from = alt, values_fill = "NO-SNP") %>%
  pivot_longer(cols = -c(sample_name, gene_name), names_to = "gene_pos", values_to = "alt") %>%
  pivot_wider(names_from = c("gene_name", "gene_pos"), values_from = alt, values_fill = "NULL") %>%
  ungroup()
```

Now we will encode the values into numerical values. We will use the following encoding:

```{r}
snp_2_num <- c(
  "NULL" = -1,
  "NO-SNP" = 0,
  "A" = 1,
  "C" = 2,
  "G" = 3,
  "T" = 4
)
```

```{r}
# Mutate all except sample_name
snps_data_wide %>%
  mutate(across(-c(sample_name), ~as.numeric(snp_2_num[.x])))
```

## AMR labels

Count how many samples are resistance to each antibiotic:

```{r}
amr_labels %>%
  select(-`SampleID`) %>%
  replace(is.na(.), 0) %>% # NOTE: if no result for a certain antibiotic, it is considered as not resistant
  summarise_all(~ sum(.x == 1)) %>%
  gather(key = "antibiotic", value = "resistant samples") %>%
  arrange(desc(`resistant samples`))
```

## Explore data

```{r}
# TODO: histogram with mean number of resistance genes per antibiotic
```

```{r}
# TODO: histogram with mean number of SNPs per antibiotic
```