---
title: "Data Cleaning"
author: "Geovanny Risco"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  github_document:
    keep_html: no
    number_sections: yes
    toc: yes
    toc_depth: 3
    df_print: tibble
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, rows.print = 25, fig.path = "figures/")
```

# Import libraries

```{r}
library(tidyverse)
```

# Constant/Config variables

```{r}
batch_number <- "_batch3"
MAX_NUMBER_OF_SNPS <- 10
MAX_NULLS_PER_ANTIBIOTIC <- 30 # In percentage
```

# Import data

```{r}
# ARGs (Antibiotic Resistance Genes)
args_data_filepath <- paste0("data/results/resfinder/args_table", batch_number, ".csv")
args_data <- read_csv(args_data_filepath, col_types = cols("sample_name" = col_character()))
## Fix/extract name of samples
args_data <- args_data %>%
  mutate(sample_name = str_extract(sample_name, "^\\w+.\\d+"))
args_data
```

```{r}
# SNPs (Single Nucleotide Polymorphisms)
snps_data_filepath <- paste0("data/results/variant_calling/snps_data", batch_number, ".tsv")
snps_data <- read_tsv(snps_data_filepath, col_names = c("chrom", "pos", "ref", "alt", "tgt", "gene_name", "gene_pos", "tax_id", "sample_name"), na = c("."))
# Fix/extract name of samples
snps_data <- snps_data %>%
  mutate(sample_name = str_extract(sample_name, "^\\w+.\\d+"))
snps_data
```

```{r}
# Results from CARD database
card_data_filepath <- paste0("data/results/card/card_results", "_batch2.5", ".tsv")
card_data <- read_tsv(card_data_filepath, na = c("n/a"))
# Fix/extract name of samples
card_data <- card_data %>%
  mutate(SAMPLE_ID = str_extract(SAMPLE_ID, "^\\w+.\\d+"))
card_data
```

```{r}
# Reference genomes (in BED format)

## Loop through reference genomes folder and read BED files
refs_genomes_dir <- "data/reference_genomes"
refs_genomes_files <- list.files(refs_genomes_dir, pattern = ".bed", full.names = TRUE, recursive = TRUE)
## Read each of the BED files and store them ina dictionary which key is the name of the file and the values a list of genes
refs_genomes <- list()
for (file in refs_genomes_files) {
  tax_id <- str_remove(basename(file), ".bed")
  refs_genomes[tax_id] <- read_tsv(file, col_select = 4)
}
```

```{r}
# AMR (Antimicrobial Resistance) labels
amr_labels <- read_csv("data/results/data_collection_ncbi/amr_labels.csv", col_types = cols("SampleID" = col_character()))
amr_labels
```

```{r}
# Load NCBI samples metadata
samples_metadata <- read_tsv("data/results/data_collection_ncbi/assembly_accession_ids+tax_ids.txt", col_names = c("biosample_accession", "assembly_accession", "tax_id"))
samples_metadata
```

For now and until BV-BRC is active again, we will filter out 1351 samples (which are not in NCBI).
In order to add BV-BRC samples, we need to parse AMR labels information in a different way:

```{r}
amr_labels <- amr_labels %>%
  filter(`SampleID` %in% samples_metadata$biosample_accession)
snps_data <- snps_data %>%
  filter(sample_name %in% samples_metadata$assembly_accession)
card_data <- card_data %>%
  filter(SAMPLE_ID %in% samples_metadata$assembly_accession)
args_data <- args_data %>%
  filter(sample_name %in% samples_metadata$assembly_accession)
```


# Clean and prepare data

First of all, we will need to clean and prepare the data in order to perform the analysis.

## ARGs

This table has the following structure:

| sample_name | GeneA | GeneB | GeneC | ... |
|:------------|-------|-------|-------|----:|
| GCA_012637185.1 | 0 | 1 | 0 | ... |
| ... | ... | ... | ... | ... |

For each gene, a boolean value is given dependending on whether the gene is resistance or not.

* 1: resistance gene
* 0: non-resistance gene

### Null values detection

```{r}
# Count number of nulls per sample
args_data %>%
  mutate(nulls = rowSums(is.na(select(., -sample_name)))) %>%
  select(sample_name, nulls) %>%
  arrange(desc(nulls))
```

We have no nulls values for ARGs.

### Outliers detection

```{r}
# For each sample, how many resistance genes are present?
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  select(sample_name, count) %>%
  arrange(desc(count))
# Mean number of resistance genes per sample
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  summarise(mean(count)) %>%
  pull()
# Boxplot summarizing above information
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  ggplot(aes(x = "", y = count)) +
  geom_boxplot() +
  labs(x = "", y = "Number of resistance genes", title = "Distribution of resistance genes per sample") +
  theme_classic()
# Histogram with density of resistance genes per sample
args_data %>%
  mutate(count = rowSums(select(., -sample_name))) %>%
  ggplot(aes(x = count)) +
  geom_histogram(aes(y = ..density..), bins = 30, color = "#000000", fill = "#0099F8") +
  geom_density(color = "#000000", fill = "#F85700", alpha = 0.6) +
  labs(x = "Number of resistance genes", y = "Density", title = "Distribution of resistance genes per sample") +
  theme_classic()
```

### Feature engineering

As all of the columns we have in this table is boolean data, there is not much to do in terms of feature engineering. 
Hoewever, we have noticed that there are some ARGs that does not contribute to resistance in any sample, that is, they 
are always 0. Since this does not provide us any information, we will remove them from the table.

```{r}
# Check length of args_data columns
original_ncols <- length(colnames(args_data))

# Filter to only columns that has any other value different than 0
args_data <- args_data %>%
  select_if(function(x) any(x != 0))

removed_ncols <- original_ncols - length(colnames(args_data))
```

After the filtering, we have removed `r removed_ncols` columns.

## SNPs

### Preparation

In this case, we will need to perform preparation steps for each sample, since the table has a different structure.

| chrom | pos | ref | alt | tgt | gene_name | gene_pos | tax_id | sample_name |
|:------|-----|-----|-----|-----|-----------|----------|--------|------------:|
| NC_002695.2 | 1250767 | T | C | T/C | ECs_1169 | 511.0 | 562 | GCA_012688215.1 |
| NC_002695.2 | 1250712 | C | A | C/A | ECs_1169 | 456.0 | 562 | GCA_012688215.1 |
| NZ_CP046317.1 | 218754 | T | G | T/G | FOC43_RS01045 | 603 | 195 | GCA_005283725.1 |
| ... | ... | ... | ... | ... | ... | ... | ... | ... |

Here is a brief description of each column:

* chrom: chromosome in which the SNP is located
* pos: position of the SNP in the chromosome
* ref: reference nucleotide (the one that is expected to be found in the sample)
* alt: alternative nucleotide (the one that is actually found in the sample, that is, the mutation/SNP)
* tgt: translated genotype, or in other words, the ref and alt nucleotides in a single string (ref/alt). #TODO: double check this
* gene_name: name of the gene in which the SNP is located
* gene_pos: position of the SNP in the gene
* tax_id: taxonomic id of the sample
* sample_name: name of the sample

Most of this information has been extracted from the VCF file generated by the variant calling pipeline. 
More information about the VCF format can be found [here](https://samtools.github.io/hts-specs/VCFv4.2.pdf).

In order to use this data for ML purposes, we need to transform it into a table with the following structure:

sample_name | gene_name1/gene1_pos1 | gene_name1/gene1_pos2 | gene_name2/gene2_pos1 | ...

For the previous example, the table would look like this:

| sample_name | ECs_1169/456 | ECs_1169/1250712 | FOC43_RS01045/603 | ... |
|:------------|--------------|------------------|--------------------|----:|
| GCA_012688215.1 | C | NO-SNP | NULL | ... |
| GCA_012637185.1 | NO-SNP | A | NULL | ... |
| GCA_005283725.1 | NULL | NULL | G | ... |

As we can see, each SNP is represented as a column, and each row represents a sample. For each SNP, we can have the following values:

* NO-SNP: no SNP found in this position of the gene, but the gene does belong to the sample
* NULL: the gene does not belong to the sample
* A, C, G, T: the SNP found in this position of the gene

In addition, we will encode these values into numerical values so that we do limit the number of ML algorithms we can use.
But before that, let's do some sanity checks.

```{r}
# Filter out SNPs with no gene name (which are the same as sample with non gene_pos)
snps_data <- snps_data %>%
  filter(!is.na(gene_name))
# Filter out SNPS which count for >5 in the same gene (this is considered an anomaly, due to reference genome, etc.) #TODO: double check this
snps_data <- snps_data %>%
  group_by(sample_name, gene_name) %>%
  mutate(count = n()) %>%
  filter(count <= MAX_NUMBER_OF_SNPS) %>%
  select(-count)
```

Pivot table with above specifications:

```{r}
snps_data_wide <- snps_data %>%
  select(sample_name, gene_name, gene_pos, alt) %>%
  pivot_wider(names_from = c("gene_pos"), values_from = alt, values_fill = "NO-SNP") %>%
  pivot_longer(cols = -c(sample_name, gene_name), names_to = "gene_pos", values_to = "alt") %>%
  pivot_wider(names_from = c("gene_name", "gene_pos"), values_from = alt, values_fill = "NULL", names_sep = "/") %>%
  ungroup()
```

Now we will encode the values into numerical values. We will use the following encoding:

```{r}
snp_2_num <- c(
  "NULL" = -1,
  "NO-SNP" = 0,
  "A" = 1,
  "C" = 2,
  "G" = 3,
  "T" = 4
)
```

```{r}
# Mutate all except sample_name
snps_data_wide <- snps_data_wide %>%
  mutate(across(-c(sample_name), ~ as.numeric(snp_2_num[.x])))
```

### Null values detection

```{r}
# Count number of nulls per sample in percentage
snps_data_wide %>%
  mutate(nulls = rowSums(select(., -sample_name) == -1) / ncol(select(., -sample_name)) * 100) %>%
  select(sample_name, nulls) %>%
  arrange(desc(nulls))
```

For most of the samples, there is very little coocurrences in terms of SNPs. 

### Outliers analysis

```{r}
# For each sample, how many SNPs are present?
snps_data_wide %>%
  mutate(count = rowSums(select(., -sample_name) > 0)) %>%
  select(sample_name, count) %>%
  arrange(desc(count))
```

```{r}
# Mean number of SNPs per sample
snps_data_wide %>%
  mutate(count = rowSums(select(., -sample_name) > 0)) %>%
  summarise(mean(count)) %>%
  pull()
```

```{r}
# Boxplot summarizing above information
snps_data_wide %>%
  mutate(count = rowSums(select(., -sample_name) > 0)) %>%
  ggplot(aes(x = "", y = count)) +
  geom_boxplot() +
  labs(x = "", y = "Number of SNPs", title = "Distribution of SNPs per sample") +
  theme_classic()
```

## SNPs from CARD

Although [CARD database](https://card.mcmaster.ca/) offers us a large variety of information about AMR vectors, we will only use the SNPs information. 
For more information about the output format, please refer to the official [documentation](https://github.com/arpcard/rgi#id72).

### Filtering

We will be filtering by the following criteria:
  * Column `Model_type` must be either `protein variant model` or `protein overexpression model`
  * They must have a value within the column `SNPs_in_Best_Hit_ARO`. NOTE: this column can have multiple values separated by commas.

```{r}	
# Filter by Model_type
card_snps_data <- card_data %>%
  filter(Model_type %in% c("protein variant model", "protein overexpression model"))

# Filter by SNPs_in_Best_Hit_ARO
card_snps_data <- card_snps_data %>%
  filter(!is.na(SNPs_in_Best_Hit_ARO))

# Explode SNPs_in_Best_Hit_ARO
card_snps_data <- card_snps_data %>%
  mutate(SNPs_in_Best_Hit_ARO = strsplit(SNPs_in_Best_Hit_ARO, ",")) %>%
  unnest(SNPs_in_Best_Hit_ARO)
```

### Exploration/Visualization

```{r}
# Boxplot showing how many SNPs are present in each sample
card_snps_data %>%
  group_by(SAMPLE_ID) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = "", y = count)) +
  geom_boxplot() +
  labs(x = "", y = "Number of SNPs", title = "Distribution of SNPs per sample") +
  theme_classic()
```

```{r}
# Histogram showing how many SNPs are present in each sample
card_snps_data %>%
  group_by(SAMPLE_ID) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = count)) +
  geom_histogram(aes(y = ..density..), bins = 30, color = "#000000", fill = "#0099F8") +
  geom_density(color = "#000000", fill = "#F85700", alpha = 0.6) +
  labs(x = "Number of SNPs", y = "Density", title = "Distribution of SNPs per sample") +
  theme_classic()
```


### Preparation

Now that we have filtered the data, we will need to transform it into a format compatible for ML algorithms, that is, a table with the features of interest as columns and the samples as rows.
In this case, the features we are interested in are the SNPs, so we will need to pivot the table so that each row represents a sample and each column represents a SNP ID (column `SNPs_in_Best_Hit_ARO`).
The value of each cell will be the number of times that the SNP appears in the sample.

```{r}
# Pivot table
card_snps_data_wide <- card_snps_data %>%
  select(SAMPLE_ID, SNPs_in_Best_Hit_ARO) %>%
  group_by(SAMPLE_ID, SNPs_in_Best_Hit_ARO) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = SNPs_in_Best_Hit_ARO, values_from = count, values_fill = 0) %>%
  ungroup()
```

## AMR labels

The structure of this table is as follows:

| SampleID | Antibiotic1 | Antibiotic2 | Antibiotic3 | ... |
|:---------|-------------|-------------|-------------|----:|
| SAMN04256112 | 0 | 1 | 0 | ... |
| ... | ... | ... | ... | ... |

Where each column represents an antibiotic and each row represents a sample. The values of each cell can be:

* 0: the sample is not resistant to the antibiotic
* 1: the sample is resistant to the antibiotic

One sample can be resistant to multiple antibiotics, so we can have multiple 1s in the same row.

### Preparation

Adapt data so it has the same sampleIds as ARGS and variant calling data. AMR labes happens to have
the biosamples accession numbers as sampleIds, so we will need to map them to their corresponding assembly
accession ids.

```{r}
# Given information in samples_metadata, replace biosample_accession with assembly_accession
amr_labels <- amr_labels %>%
  left_join(distinct(samples_metadata, biosample_accession, .keep_all = TRUE), by = c("SampleID" = "biosample_accession")) %>%
  select(-c(`SampleID`, tax_id)) %>%
  rename(`SampleID` = assembly_accession) %>%
  select(SampleID, everything())
```

### Cleaning

We will remove those antibiotics with more than `r MAX_NULLS_PER_ANTIBIOTIC`% of null values.

```{r}
# Count null values per antibiotic (each column) in percentage
nulls_per_antibiotic <- amr_labels %>%
  select(-`SampleID`) %>%
  summarise_all(~ sum(is.na(.x)) / nrow(amr_labels) * 100) %>%
  gather(key = "antibiotic", value = "% of null values") %>%
  arrange(desc(`% of null values`))
knitr::kable(nulls_per_antibiotic)
```

```{r}
# Remove antibiotics with more than 30% of null values
antibiotics_to_remove <- nulls_per_antibiotic %>%
  filter(`% of null values` > 30) %>%
  pull(antibiotic)
amr_labels <- amr_labels %>%
  select(-all_of(antibiotics_to_remove))
```

### Exploration

Count how many samples are resistance to each antibiotic:

```{r, display = 'inline-block'}
resistant_samples_per_antibiotic <- amr_labels %>%
  select(-`SampleID`) %>%
  summarise_all(~ sum(.x == 1, na.rm = TRUE)) %>%
  gather(key = "antibiotic", value = "resistant samples") %>%
  arrange(desc(`resistant samples`))
knitr::kable(resistant_samples_per_antibiotic)
```

```{r}
# Bar plot with number of resistant samples per antibiotic
resistant_samples_per_antibiotic %>%
  ggplot(aes(x = antibiotic, y = `resistant samples`)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Antibiotic", y = "Number of resistant samples")
```

# Explore data

Median number of resistant genes per antibiotic:

```{r}
# Boxplot with median number of resistant genes per antibiotic
args_data %>%
  mutate(n_args = rowSums(select(., -sample_name))) %>%
  select(sample_name, n_args) %>%
  left_join(amr_labels, by = c("sample_name" = "SampleID")) %>%
  pivot_longer(cols = -c(sample_name, n_args), names_to = "antibiotic", values_to = "resistant") %>%
  filter(resistant == 1) %>%
  ggplot(aes(x = antibiotic, y = n_args, color = antibiotic)) +
  geom_boxplot() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  labs(x = "Antibiotic", y = "Number of resistant genes")
```

Median number of SNPs per antibiotic:

```{r}
# Boxplot with median number of SNPs per antibiotic
# In this case, SNPS can have multiple values, not only 0 and 1. We will count those with values > 0 as valid SNPs conferring resistance
snps_data %>%
  ungroup() %>%
  select(sample_name) %>%
  group_by(sample_name) %>%
  summarise(n_snps = n()) %>%
  left_join(amr_labels, by = c("sample_name" = "SampleID")) %>%
  pivot_longer(cols = -c(sample_name, n_snps), names_to = "antibiotic", values_to = "resistant") %>%
  filter(resistant == 1) %>%
  ggplot(aes(x = antibiotic, y = n_snps, color = antibiotic)) +
  geom_boxplot() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  labs(x = "Antibiotic", y = "Number of SNPs")
```

Median number of CARD SNPs per antibiotic:

```{r}
# Boxplot with median number of CARD SNPs per antibiotic
card_snps_data %>%
  group_by(SAMPLE_ID) %>%
  summarise(n_card_snps = n()) %>%
  left_join(amr_labels, by = c("SAMPLE_ID" = "SampleID")) %>%
  pivot_longer(cols = -c(SAMPLE_ID, n_card_snps), names_to = "antibiotic", values_to = "resistant") %>%
  filter(resistant == 1) %>%
  ggplot(aes(x = antibiotic, y = n_card_snps, color = antibiotic)) +
  geom_boxplot() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  labs(x = "Antibiotic", y = "Number of CARD SNPs")
```


# Save data

```{r}
snps_data_output_path <- paste0("data/results/variant_calling/snps_data", batch_number, "_cleaned.tsv")
snps_data_wide %>%
  write_tsv(snps_data_output_path)

card_snps_data_output_path <- paste0("data/results/card/card_snps_data", "_batch2.5", "_cleaned.tsv")
card_snps_data_wide %>%
  write_tsv(card_snps_data_output_path)

args_data_output_path <- paste0("data/results/resfinder/args_data", batch_number, "_cleaned.tsv")
args_data %>%
  write_tsv(args_data_output_path)

amr_labels_output_path <- paste0("data/results/data_collection_ncbi/amr_labels", batch_number, "_cleaned.tsv")
amr_labels %>%
  write_tsv(amr_labels_output_path)
```
